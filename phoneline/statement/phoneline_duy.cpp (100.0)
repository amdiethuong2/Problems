#include<stdio.h>
#include<string.h>
#define PB push_back
#define MP make_pair
#define fi first
#include<algorithm>
#include<vector>
#define se second
#define M 1020
#include<queue>
using namespace std;
typedef pair<int,int> ii;
typedef pair<int,ii> II;
vector<ii> V[M];
int n,m,k;
int d[M][M];
int max(int a,int b){
    if(a>b) return a;
    return b;
}
void load_graph(){
    scanf("%d %d %d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        int u,v,c;
        scanf("%d %d %d",&u,&v,&c);
        V[u].PB(MP(v,c));
        V[v].PB(MP(u,c));
    }
}
void solve(){
    for(int i=1;i<=n;i++)
        for(int j=0;j<=k;j++) d[i][j] = 100000000;
    d[1][0] = 0;
    priority_queue < II , vector<II> , greater<II> >pq;
    pq.push(MP(0,MP(1,0)));
    while(!pq.empty()){
        int dis = pq.top().fi;
        int u = pq.top().se.fi;
        int free = pq.top().se.se;
        pq.pop();
        if(dis!=d[u][free]) continue;
        for(int i=0;i<V[u].size();i++){
            int v = V[u][i].fi;
            int c = V[u][i].se;
            if(free < k && d[v][free+1] > d[u][free]){
                d[v][free+1] = d[u][free];
                pq.push(MP(d[v][free+1],MP(v,free+1)));
            }
            if(d[v][free] > max(d[u][free],c)){
                d[v][free] = max(d[u][free],c);
                pq.push(MP(d[v][free],MP(v,free)));
            }
        }
    }
    int mmin = 100000000;
    for(int i=0;i<=k;i++)
        if(d[n][i] < mmin)
            mmin = d[n][i];
    if(mmin == 100000000) printf("-1");
    else printf("%d",mmin);
}
main(){
   // freopen("test.inp","r",stdin);
    load_graph();
    solve();
}
